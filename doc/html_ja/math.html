


<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Math</title>
</head>
<body>
<a name="TOP">&nbsp;</a>
<h1><a href="./ngraph.html">データの加工</a></h1>
<ul>
<li><a href="#TRANSFORM">概要</a>
<li><a href="#FORMULA_LITERAL">数式変換の数値リテラル</a>
<li><a href="#FORMULA_CONST">数式変換の定数</a>
<li><a href="#FORMULA_PAR">数式変換のパラメータ</a>
<li><a href="#FORMULA_VAR">数式変換の変数</a>
<li><a href="#FORMULA_OP">数式変換の演算子</a>
<li><a href="#FORMULA_FUNC">数式変換の関数</a>
<li><a href="#OP_PRECEDENCE">数式変換の関数・演算子の優先順位</a>
<li><a href="#OP_EXAMPLE">数式変換の使用例</a>

<li><a href="#NEW_TRANSFORM">GTK 版で追加された機能、変更点</a>
<li><a href="#NEW_FORMULA_LITERAL">数値リテラル</a>
<li><a href="#NEW_FORMULA_CONST">定数</a>
<li><a href="#NEW_FORMULA_CONST_DEF">定数定義</a>
<li><a href="#NEW_FORMULA_PAR">パラメータ</a>
<li><a href="#NEW_FORMULA_VAR">変数</a>
<li><a href="#NEW_FORMULA_ARRAY">配列</a>
<li><a href="#NEW_FORMULA_USR_FUNC">ユーザ定義関数</a>
<li><a href="#NEW_FORMULA_OP">演算子</a>
<li><a href="#NEW_FORMULA_FUNC">関数</a>
<li><a href="#NEW_OP_PRECEDENCE">演算子の優先順位</a>

</ul>

<br>
<hr size="5">
<br>


<a name="TRANSFORM">&nbsp;</a>
<h2><a href="#TOP">概要</a></h2>
<br>
<div>
描画は隣接平均, 数式変換などデータの加工を行った後に行われます。
グラフを作成する際その処理手順を意識することが重要な場合があります。
以下にデータの流れを示します。<br>
<br>
<center>
データファイル<br>
↓<br>
数式変換<br>
↓<br>
マスクされたデータを削除<br>
↓<br>
移動されたデータを移動<br>
↓<br>
隣接平均<br>
↓<br>
[曲線の補間係数, 最小二乗フィットの係数を求める]<br>
↓<br>
出力(グラフ描画)<br>
</center>
<br>
ロググラフを作成する場合, 曲線の補間はデータを対数変換した後に行われるので通常の線形グラフとロググラフでは結果が異なります。
最小二乗法に関してはロググラフでも通常の線形グラフと同じ係数を求めます。<br>
</div>

<br>
<hr>
<br>


<a name="FORMULA_LITERAL">&nbsp;</a>
<h2><a href="#TOP">数式変換で使用できる数値リテラル</a></h2>
<br>
<div>
  <dl>
    <dt>1</dt>
    <dt>1.0</dt>
    <dt>1.0E3</dt>
    <dd>
      <p>浮動小数点</p>
    </dd>
  </dl>
</div>

<br>
<hr>
<br>


<a name="FORMULA_CONST">&nbsp;</a>
<h2><a href="#TOP">数式変換で使用できる定数</a></h2>
<br>
<div>
<table border=1>
<tr><td>PI</td><td>円周率</td></tr>
<tr><td>E</td><td>自然対数の底</td></tr>
<tr><td>EULER</td><td>オイラーの定数</td></tr>
<tr><td>NAN</td><td>欠損データ エラー表示</td></tr>
<tr><td>UNDEF</td><td>欠損データ エラー非表示</td></tr>
<tr><td>CONT</td><td>欠損データ (データ線は結合)</td></tr>
<tr><td>BREAK</td><td>欠損データ (データ線は分断)</td></tr>
<tr><td>NUM</td><td>データの個数</td></tr>
<tr><td>MINX</td><td>(X) column の生データの最小値</td></tr>
<tr><td>MAXX</td><td>(X) column の生データの最大値</td></tr>
<tr><td>MINY</td><td>(Y) column の生データの最小値</td></tr>
<tr><td>MAXY</td><td>(Y) column の生データの最大値</td></tr>
<tr><td>SUMX</td><td>(X) column の生データの和</td></tr>
<tr><td>SUMY</td><td>(Y) column の生データの和</td></tr>
<tr><td>SUMXX</td><td>(X) column の生データの二乗和</td></tr>
<tr><td>SUMYY</td><td>(Y) column の生データの二乗和</td></tr>
<tr><td>SUMXY</td><td>(X) column, (Y) column の生データの積和</td></tr>
<tr><td>AVX</td><td>(X) column の生データの平均</td></tr>
<tr><td>AVY</td><td>(Y) column の生データの平均</td></tr>
<tr><td>SGX</td><td>(X) column の生データの標準偏差</td></tr>
<tr><td>SGY</td><td>(Y) column の生データの標準偏差</td></tr>
<tr><td>FIRST</td><td>diagonal, errorbar など一行のデータで2回の変換が行われる場合、1回目の呼出しで真(=1)、2回目の呼出しで偽(=0)</td></tr>
<tr><td>%D</td><td>データファイルの番号</td></tr>
</table>
</div>

<br>
<hr>
<br>


<a name="FORMULA_PAR">&nbsp;</a>
<h2><a href="#TOP">数式変換で使用できるパラメータ</a></h2>
<br>
<div>
<table border=1>
<tr><td>%0</td><td>データを読み込んだ順番に1から番号をつけたときの値</td></tr>
<tr><td>%1〜%999</td><td>同一行中 1〜999 カラムの生データ</td></tr>
<tr><td>%Fxx1〜%Fxx999</td><td>データファイル xx の同じ行の 1〜999 カラムの生データ</td></tr>
</table>
</div>

<br>
<hr>
<br>


<a name="FORMULA_VAR">&nbsp;</a>
<h2><a href="#TOP">数式変換で使用できる変数</a></h2>
<br>
<div>
<table border=1>
<tr><td>X</td><td>(X)column の生のデータ</td></tr>
<tr><td>Y</td><td>(Y)column の生のデータ</td></tr>
</table>
</div>

<br>
<hr>
<br>



<a name="FORMULA_OP">&nbsp;</a>
<h2><a href="#TOP">数式変換で使用できる演算子</a></h2>
<br>
<div>
<table border=1>
<tr><td>-+</td><td>符号</td></tr>
<tr><td>+ - * /</td><td>四則演算</td></tr>
<tr><td>\</td><td>実数乗算の乗余</td></tr>
<tr><td>^</td><td>ベキ乗</td></tr>
<tr><td>!</td><td>階乗(引数は 169 以下の正の整数)</td></tr>
<tr><td>( )</td><td>括弧(20 重まで)</td></tr>
<tr><td>=</td><td>式の終端(省略可能) 別の式を後に続けることが可能</td></tr>
</table>
</div>

<br>
<hr>
<br>



<a name="FORMULA_FUNC">&nbsp;</a>
<h2><a href="#TOP">数式変換で使用できる関数</a></h2>
<br>
<div>
<h3>変換関数</h3>
<table border=1>
<tr><td>ABS(x)</td><td>絶対値</td></tr>
<tr><td>SIGN(x)</td><td>正負の符号</td></tr>
<tr><td>INT(x)</td><td>0に向かって切捨てた整数部</td></tr>
<tr><td>GAUSS(x)</td><td>ガウスの記号[ ] ([n]はnを越えない最大の整数)</td></tr>
<tr><td>FRAC(x)</td><td>小数部</td></tr>
<tr><td>ROUND(x)</td><td>四捨五入した整数部</td></tr>
<tr><td>MIN(x,y)</td><td>x, y の小さい方</td></tr>
<tr><td>MAX(x,y)</td><td>x, y の大きい方</td></tr>
</table>
<br>
<h3>初等関数</h3>
<table border=1>
<tr><td>SQR(x)</td><td>二乗</td></tr>
<tr><td>SQRT(x)</td><td>平方根</td></tr>
<tr><td>EXP(x)</td><td>指数(x≦690)</td></tr>
<tr><td>LN(x)</td><td>自然対数</td></tr>
<tr><td>LOG(x)</td><td>常用対数</td></tr>
<tr><td>SIN(x)</td><td>サイン</td></tr>
<tr><td>COS(x)</td><td>コサイン</td></tr>
<tr><td>TAN(x)</td><td>タンジェント</td></tr>
<tr><td>ASIN(x)</td><td>逆サイン</td></tr>
<tr><td>ACOS(x)</td><td>逆コサイン</td></tr>
<tr><td>ATAN(x)</td><td>逆タンジェント</td></tr>
<tr><td>SINH(x)</td><td>ハイパボリックサイン</td></tr>
<tr><td>COSH(x)</td><td>ハイパボリックコサイン</td></tr>
<tr><td>TANH(x)</td><td>ハイパボリックタンジェント</td></tr>
<tr><td>ASINH(x)</td><td>逆ハイパボリックサイン</td></tr>
<tr><td>ACOSH(x)</td><td>逆ハイパボリックコサイン</td></tr>
<tr><td>ATANH(x)</td><td>逆ハイパボリックタンジェント</td></tr>
</table>
<br>
<h3>特殊関数</h3>
<table border=1>
<tr><td>RAND(x)</td><td>0≦RAND(x)＜x (x＞0のとき)の乱数</td></tr>
<tr><td>THETA(x)</td><td>階段関数(x≧0 のとき 1, それ以外は 0 )</td></tr>
<tr><td>DELTA(x)</td><td>クロネッカーのδ(x=0 のとき 1, それ以外は 0)</td></tr>
<tr><td>GAMMA(x)</td><td>ガンマ関数 Γ(x)</td></tr>
<tr><td>ICGAM(m,x)</td><td>不完全ガンマ関数 Γ(μ,x)</td></tr>
<tr><td>ERFC(x)</td><td>誤差関数 Erfc(x)</td></tr>
<tr><td>QINV(x)</td><td>誤差関数 Erfc(x) の逆関数</td></tr>
<tr><td>EI(x)</td><td>積分指数関数 Ei(x)</td></tr>
<tr><td>BETA(x,y)</td><td>ベータ関数 B(p,q)</td></tr>
<tr><td>JN(n,x)</td><td>第1種n次ベッセル関数</td></tr>
<tr><td>YN(n,x)</td><td>第2種n次ベッセル関数</td></tr>
<tr><td>PN(n,x)</td><td>ルジャンドル多項式</td></tr>
<tr><td>LGN(n,a,x)</td><td>ラゲール倍多項式</td></tr>
<tr><td>HN(n,x)</td><td>エルミート多項式</td></tr>
<tr><td>TN(n,x)</td><td>チェビシフ多項式</td></tr>
<tr><td>MJD(year,month,day)</td><td>修正ユリウス日(year, month, day はグレゴリオ暦)</td></tr>
</table>
<br>
<h3>論理関数</h3>
<p>
<ul>
  <li> 0 を偽, それ以外を真とする。
</ul>
</p>
<table border=1>
<tr><td>EQ(x,y)</td><td>x＝y のとき真(=1)</td></tr>
<tr><td>NEQ(x,y)</td><td>x≠y のとき真(=1)</td></tr>
<tr><td>GE(x,y)</td><td>x≧y のとき真(=1)</td></tr>
<tr><td>GT(x,y)</td><td>x＞y のとき真(=1)</td></tr>
<tr><td>LE(x,y)</td><td>x≦y のとき真(=1)</td></tr>
<tr><td>LT(x,y)</td><td>x＜y のとき真(=1)</td></tr>
<tr><td>NOT(x)</td><td>x＝0 のとき真(=1)</td></tr>
<tr><td>OR(x,y)</td><td>(x≠0) or (y≠0) のとき真(=1)</td></tr>
<tr><td>AND(x,y)</td><td>(x≠0) and (y≠0) のとき真(=1)</td></tr>
<tr><td>XOR(x,y)</td><td>(x≠0) xor (y≠0) のとき真(=1)</td></tr>
</table>
<br>
<h3>その他の関数</h3>
<table border=1>
<tr><td>SUM(x)</td><td>積算(一つの数式で 10 個まで)</td></tr>
<tr><td>DIF(x)</td><td>差分(一つの数式で 10 個まで)</td></tr>
<tr><td>M(n,x)</td><td>引数を第nメモリーに代入する(n=0〜19)</td></tr>
<tr><td>RM(n)</td><td>現在の第nメモリーの値(n=0〜19)</td></tr>
<tr><td>F(x,y,z)</td><td>ユーザ定義関数</td></tr>
<tr><td>G(x,y,z)</td><td>ユーザ定義関数</td></tr>
<tr><td>H(x,y,z)</td><td>ユーザ定義関数</td></tr>
<tr><td>COLOR(0,x)</td><td>R値を x (0≦x＜256)に設定</td></tr>
<tr><td>COLOR(1,x)</td><td>G値を x (0≦x＜256)に設定</td></tr>
<tr><td>COLOR(2,x)</td><td>B値を x (0≦x＜256)に設定</td></tr>
<tr><td>COLOR(3,x)</td><td>RGB値を x (0≦x＜256)に設定</td></tr>
<tr><td>RGB(r,g,b)</td><td>色のRGB値をそれぞれ r, g, b (0≦r,g,b≦1)に設定</td></tr>
<tr><td>HSB(h,s,b)</td><td>色のHSB値をそれぞれ h, s, b (0≦h,s,b≦1)に設定</td></tr>
<tr><td>MARKSIZE(x)</td><td>マークのサイズをXに設定</td></tr>
<tr><td>MARKTYPE(x)</td><td>マークの種類をXに設定</td></tr>
<tr><td>IF(x,ex1,ex2)</td><td>x≠0のときex1, x=0のときex2 (ネストは20まで)</td></tr>
<tr><td>FOR(m,begin,end,step,ex)</td><td>第mメモリの値がbeginからendになるまでstepでexを繰り返す</td></tr>
</table>
</div>

<br>
<hr>
<br>


<a name="OP_PRECEDENCE">&nbsp;</a>
<h2><a href="#TOP">関数・演算子の優先順位</a></h2>
<br>
<div>
<table border=1>
<tr><td>高</td><td>E (指数表記)</td></tr>
<tr><td>↑</td><td>() (括弧)</td></tr>
<tr><td> </td><td>- (負の符号)</td></tr>
<tr><td> </td><td>関数</td></tr>
<tr><td> </td><td>^ !</td></tr>
<tr><td> </td><td>* / \</td></tr>
<tr><td>↓</td><td>+ - </td></tr>
<tr><td>低</td><td>= </td></tr>
</table>
</div>

<br>
<hr>
<br>

<a name="OP_EXAMPLE">&nbsp;</a>
<h2><a href="#TOP">数式変換の使用例</a></h2>
<br>
<ul>
<li><b>= 使用例</b>
<br>
<br>
= は式の終端を示しますが、さらに続けて別の式を書くことができます。
式の値は一番最後の式の値になります。
例えば、長い式が何度も現れるときメモリ関数と組み合わせて
<p>
M(0,...式...)= ... RM(0) .... =
</p>
のようにすれば同じ式は１度書くだけですみます。また式最後の = は省略できます。
<br>
<br>

<li><b>メモリ関数 M(), RM() 使用例</b>
<br>
<br>
M() はメモリへの代入、RM() は読みだしです。
またメモリはデータファイル先頭から最後まで有効です(ただし，X, Yの変換式で独立)。
例えば
<p>
M(0,RM(0)+Y)=
</p>
とすることで Y の積算グラフを描画することができます。
<br>
<br>

<li><b>関数 DIF() 使用例</b>
<br>
<br>
関数 DIF() は微分でなく差分を返す関数です。
現在のデータがデータファイル中 n 番目としそれを Y(n) で表すとすると
<p>
DIF(Y)=Y(n) - Y(n-1)
</p>
です。これを用い簡単に微分近似値を求めるには
<p>
DIF(Y)/DIF(X)
</p>
とします。
<p>
DIF(Y)/DIF(X)は {Y(n)-Y(n-1)} / {X(n)-X(n-1)} になります。
</p>
この時、Xの変換数式を
<p>
X-DIF(X)*0.5
</p>
としてXを"現在のデータと一つ前のデータの中間値"としておいた方がより真に近いグラフが得られると思われます。
<p>
X変換式: X-DIF(X)*0.5 (これは { X(n-1)+X(n) }*0.5 になります)<br>
Y変換式: DIF(Y)/DIF(X) (これは { Y(n)-Y(n-1) } / { X(n)-X(n-1) } になります)
</p>
<p>
DIF() は現在のデータと一つ前のデータとの差分を返しますから、Y-DIF(Y) とすることで一つ前のデータを取り出すことができます。
同様に Y-DIF(Y)-DIF(Y-DIF(Y)) で2つ前のデータを取り出すことができます。
 Y-DIF(Y)-DIF(Y-DIF(Y))-DIF(Y-DIF(Y)-DIF(Y-DIF(Y)))は3つ前のデータです．
</p>
<p>
一番初めの DIF() の戻り値は"不定"です．このため，式全体の値も"不定"となり、結果としてデータの個数は1つ減ります(一番初めのデータに差分は存在しない)。
また DIF() をいくつも含む式では、全ての DIF() が初期化されるまで式全体の値は"不定"です。
例えば DIF() をネストして DIF(DIF()) のように使った場合、一番初めのデータでは内側の DIF() が初期化されその戻り値は不定の為、外側の DIF() の初期化は行われません。
外側の DIF() が初期化されるのは 2番目のデータの時です。
従ってデータの個数は2つ減ることになります。
</p>
<br>
<br>

<li><b>関数 SUM() 使用例</b>
<br>
<br>
関数 SUM() は積算を返す関数です。
現在のデータが n 番目としそれを Y(n) で表すとすると
<p>
SUM(Y)=Σ Y(n) (n=1..n)
</p>
これを用い簡単に積分近似値を求めるには
<p>
SUM(Y*DIF(X))
</p>
とします。
<p>
SUM(Y*DIF(X)) は Σ Y(n)*{ X(n)-X(n-1) } (n=1..n) になります。
</p>
また、台形公式を用いて積分近似値を評価したい場合
<p>
SUM(0.5*(2*Y-DIF(Y))*DIF(X))
</p>
とします。
<p>
SUM(0.5*(2*Y-DIF(Y))*DIF(X)) は Σ(Y(n-1)+Y(n))/2*{X(n)-X(n-1)} (n=1..n) になります。
</p>
さらに積分の上限(b)、下限(a)を指定したい場合は階段関数 THETA() を用い
<p>
SUM(0.5*(2*Y-DIF(Y))*DIF(X)*THETA(X-a)*THETA(b-X))
</p>
とします。IF() を使って
<p>
IF(AND(GE(x,a),LE(x,b)),INTEG(0.5*(2*Y-DIF(Y))*DIF(X)),0)
</p>
としても可能です。
<br>
<br>

<li><b>関数 IF() 使用例</b>
<br>
<br>
IF(x,ex1,ex2) は x が真(<>0)のとき ex1 を，偽(=0)のとき ex2 を返す関数です。
x には論理関数を使うと便利です。例えば次の式
<p>
IF( LT(x,0), 0, SQRT(x) )
</p>
は x<0 のとき 0、x>=0 のとき√x を返す関数になります。また必ず ex1, ex2 どちらか一方しか評価されません。
例えば
<p>
IF( EQ(%00,1), M(0,値), ...式... )
</p>
のような使い方をしたとき M(0,値) は EQ(%00,1) が真のとき(すなわちデータの最初)だけ実行されるので、メモリ関数の初期化に使えます。
<br>
<br>

<li><b>関数 MARKSIZE(), COLOR() 使用例</b>
<br>
<br>
MARKSIZE()、COLOR()関数は数学関数では無く、それぞれプロットされたマークのサイズ、色を指定する関数です。
例えば、(x,y,z) の 3 カラムから成るデータファイルがあり、マークのサイズを z の値で変更したいような場合には
<p>
MARKSIZE(%03)
</p>
とします。ただこれですと、プロットされるデータも %03 となりますので、前述の = を使って
<p>
MARKSIZE(%03)=Y
</p>
とするのが正しい使い方です。
COLOR()関数も同様で
<p>
COLOR(3,%03)=Y
</p>
のように使います。
<br>
</ul>

<hr>


<a name="NEW_TRANSFORM">&nbsp;</a>
<h1><a href="#TOP">GTK 版で追加された機能、変更点</a></h1>

<p>以下に記載されている機能はオリジナルの Ngraph とは互換性がありません。使用する際には注意してください。</p>

<a name="NEW_FORMULA_LITERAL">&nbsp;</a>
<h2><a href="#TOP">数値リテラル</a></h2>
<br>
<div>
  <dl>
    <dt>0xffff</dt>
    <dd>
      <p>16進整数</p>
    </dd>
    <dt>0b1011</dt>
    <dd>
      <p>2進整数</p>
    </dd>
    <dt>0o377</dt>
    <dd>
      <p>8進整数</p>
    </dd>
  </dl>
  <p>数字が連続している部分は見やすくするため任意の箇所に空白を入れることが出来ます (例 123 456.789 E8) 。</p>
</div>

<br>
<hr>
<br>


<a name="NEW_FORMULA_CONST">&nbsp;</a>
<h2><a href="#TOP">定数</a></h2>
<br>
<div>
<table border=1>
<tr><td>MASK</td><td>マスクに設定された行数</td></tr>
<tr><td>MOVE</td><td>移動に設定された行数</td></tr>
<tr><td>%N</td><td>データファイルの数</td></tr>
</table>
</div>

<br>
<hr>
<br>

<a name="NEW_FORMULA_CONST_DEF">&nbsp;</a>
<h2><a href="#TOP">定数定義</a></h2>
<br>
<div>
<table border=1>
<tr><td>const x:exp</td><td>
    x は英字で始まり英数字または _ から構成される文字列、exp は任意の数式。<br>
    <ul>
      <li> 既存の定数は上書きできません。
      <li> 数式 exp は数式変換実行時ではなく構文解析時に解釈されます。
      <li> 数式 exp 中ではパラメータ、関数 sum(), dif() は使用できません。
    </ul>
</table>
</div>

<br>
<hr>
<br>


<a name="NEW_FORMULA_VAR">&nbsp;</a>
<h2><a href="#TOP">変数</a></h2>
<br>
<div>
<table border=1>
<tr><td>E, X, Y 以外のアルファベット一文字</td><td>ユーザが自由に使用できます (代入されていない変数は 0 に初期化されています) 。</td></tr>
</table>
</div>

<br>
<hr>
<br>


<a name="NEW_FORMULA_ARRAY">&nbsp;</a>
<h2><a href="#TOP">配列</a></h2>
<br>
<div>
<table border=1>
  <tr>
    <td>x[n]</td>
    <td>
      x は英字で始まり英数字または _ から構成される文字列、n は任意の数式。<br>
      未代入の配列要素は 0 に初期化されています。<br>
      配列の添字は整数に丸められます。<br>
      配列の添字の上限は 65535 です。<br>
      配列の添字に負の数値を使用した場合、配列の末尾からのインデックスとみなします。<br>
  </td>
  </tr>
</table>
</div>

<br>
<hr>
<br>


<a name="NEW_FORMULA_USR_FUNC">&nbsp;</a>
<h2><a href="#TOP">ユーザ定義関数</a></h2>
<br>
<div>
<table border=1>
<tr>
  <td>def func(a,b,...) {exp} </td>
  <td>
    仮引数 a, b, ... の関数 func を定義します。 <br>
    配列を渡すときは仮引数を @a の様に指定してください。配列は参照渡しとなります。<br>
    exp には任意の数式を指定できますが、以下の制限があります。<br>
    <ul>
     <li> パラメータ (%0, %F0001 など) は使用できません。
     <li> 関数 dif(), sum() は使用できません。
     <li> 関数定義はネストできません。
    </ul>
  </td>
</tr>
</table>
</div>

<br>
<hr>
<br>


<a name="NEW_FORMULA_OP">&nbsp;</a>
<h2><a href="#TOP">演算子</a></h2>
<br>
<div>
<table border=1>
<tr><td>:</td><td>代入</td></tr>
<tr><td>-:</td><td>自己代入</td></tr>
<tr><td>+:</td><td>自己代入</td></tr>
<tr><td>*:</td><td>自己代入</td></tr>
<tr><td>/:</td><td>自己代入</td></tr>
<tr><td>\:</td><td>自己代入</td></tr>
<tr><td>^:</td><td>自己代入</td></tr>
<tr><td>!:</td><td>自己代入</td></tr>
<tr><td>::</td><td>比較 (C の == に対応) </td></tr>
<tr><td>!:</td><td>比較 (C の != に対応) </td></tr>
<tr><td>&lt;:</td><td>比較 (C の &lt;= に対応) </td></tr>
<tr><td>&gt;:</td><td>比較 (C の &gt;= に対応) </td></tr>
<tr><td>&lt;</td><td>比較</td></tr>
<tr><td>&gt;</td><td>比較</td></tr>
<tr><td>&amp;&amp;</td><td>論理積</td></tr>
<tr><td>||</td><td>論理和</td></tr>
</table>
</div>

<br>
<hr>
<br>


<a name="NEW_FORMULA_FUNC">&nbsp;</a>
<h2><a href="#TOP">関数</a></h2>
<p>
<ul>
  <li> 引数は省略することが出来ます。引数が省略された場合 0 が渡されます。
  <li> IF() 関数のネスト数、DIF(), SUM() 関数の数の制限はなくなりました。
</ul>
</p>
<div>
<h3>変換関数</h3>
<table border=1>
<tr><td>MIN(a,b,c,...)</td><td>引数のうちもっとも小さな値 (引数の数は 64 個まで)</td></tr>
<tr><td>MAX(a,b,c,...)</td><td>引数のうちもっとも大きな値 (引数の数は 64 個まで)</td></tr>
</table>
<br>

<h3>特殊関数</h3>
<table border=1>
<tr><td>ICBETA(x,y)</td><td>不完全ベータ関数 I(a,b,x) (0 &lt;= x &lt;= 1) </td></tr>
</table>

<br>
<h3>論理関数</h3>
<p>
<ul>
  <li> 0 を偽, それ以外を真とする。
</ul>
</p>
<table border=1>
<tr><td>ISNORMAL(x)</td><td>x が通常の数値の場合真</td></tr>
<tr><td>ISBREAK(x)</td><td>x が BREAK の場合真</td></tr>
<tr><td>ISCONT(x)</td><td>x が CONT の場合真</td></tr>
<tr><td>ISNAN(x)</td><td>x が NAN の場合真</td></tr>
<tr><td>ISUNDEF(x)</td><td>x が UNDEF の場合真</td></tr>
</table>
<br>
<h3>その他の関数</h3>
<table border=1>
<tr><td>SIZE(x)</td><td>配列 x の要素数</td></tr>
<tr><td>SORT(x)</td><td>配列 x を整列する</td></tr>
<tr><td>RSORT(x)</td><td>配列 x を逆順に整列する</td></tr>
<tr><td>COLOR(4,x)</td><td>R2値を x (0≦x＜256)に設定</td></tr>
<tr><td>COLOR(5,x)</td><td>G2値を x (0≦x＜256)に設定</td></tr>
<tr><td>COLOR(6,x)</td><td>B2値を x (0≦x＜256)に設定</td></tr>
<tr><td>COLOR(7,x)</td><td>R2, G2, B2 値を x (0≦x＜256)に設定</td></tr>
<tr><td>HSB2(h,s,b)</td><td>R2, G2, B2, の値を、HSB値からそれぞれ h, s, b (0≦h,s,b≦1)に設定</td></tr>
<tr><td>RGB2(r,g,b)</td><td>R2, G2, B2, の値を r, g, b (0≦r,g,b≦1)から設定</td></tr>
<tr><td>UNLESS(x,ex1,ex2)</td><td>x≠0のときex2, x=0のときex2</td></tr>
<tr><td>FOR(m,begin,end,step,ex)</td><td>第mメモリの値に begin から end まで step で 値を設定し、ex を繰り返す</td></tr>
</table>
</div>

<br>
<hr>
<br>


<a name="NEW_OP_PRECEDENCE">&nbsp;</a>
<h2><a href="#TOP">演算子の優先順位</a></h2>
<p>演算子 + - (正負の符号) の優先順位がオリジナルと異なっています。</p>
<div>
<table border=1>
<tr><td>高</td><td>!</td></tr>
<tr><td>↑</td><td>^</td></tr>
<tr><td> </td><td>+ - (正負の符号)</td></tr>
<tr><td> </td><td>* / \</td></tr>
<tr><td> </td><td>+ -</td></tr>
<tr><td> </td><td>&lt; &lt: &gt; &gt;:</td></tr>
<tr><td> </td><td>:: !:</td></tr>
<tr><td> </td><td>&amp;&amp;</td></tr>
<tr><td>↓</td><td>||</td></tr>
<tr><td>低</td><td>:(+:, -: ... )</td></tr>
</table>
</div>



<br>
<hr>
<br>

</body></html>
