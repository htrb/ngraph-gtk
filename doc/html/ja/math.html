<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>Math</title>
</head>
<body>
<a name="TOP">&nbsp;</a>
<h1><a href="./ngraph.html">データの加工</a></h1>
<ul>
 <li><a href="#TRANSFORM">概要</a>
 <li><a href="#FORMULA_COMMENT">コメント</a>
 <li><a href="#FORMULA_LITERAL">数値リテラル</a>
 <li><a href="#FORMULA_CONST">定数</a>
 <li><a href="#CONST_DEF">定数定義</a>
 <li><a href="#FORMULA_PAR">パラメータ</a>
 <li><a href="#FORMULA_VAR">変数</a>
 <li><a href="#STRINGS">文字列</a>
 <li><a href="#ARRAY">配列</a>
 <li><a href="#USR_FUNC">ユーザ定義関数</a>
 <li><a href="#FORMULA_OP">演算子</a>
 <li><a href="#FORMULA_FUNC">関数</a>
   <ul>
    <li> <a href="#TRANSFORM_FUNC">変換関数</a>
    <li> <a href="#ELEMENTARY_FUNC">初等関数</a>
    <li> <a href="#SPECIAL_FUMC">特殊関数</a>
    <li> <a href="#DATETIME_FUMC">日付時刻関数</a>
    <li> <a href="#LOGIC_FUNC">論理関数</a>
    <li> <a href="#ARRAY_FUNC">配列操作関数</a>
    <li> <a href="#MEMORY_FUNC">メモリー操作関数</a>
    <li> <a href="#DRAWING_FUNC">図形描画関数</a>
    <li> <a href="#OTHER_FUNC">その他の関数</a>
   </ul>
 <li><a href="#OP_PRECEDENCE">演算子の優先順位</a>
 <li><a href="#OP_EXAMPLE">数式変換の使用例</a>
</ul>

<br>
<hr size="5">
<br>


<h2><a name="TRANSFORM" href="#TOP">概要</a></h2>
<br>
<div>
描画は隣接平均, 数式変換などデータの加工を行った後に行われます。
グラフを作成する際その処理手順を意識することが重要な場合があります。
以下にデータの流れを示します。<br>
<br>
<center>
データ<br>
↓<br>
数式変換<br>
↓<br>
マスクされたデータを削除<br>
↓<br>
移動されたデータを移動<br>
↓<br>
隣接平均<br>
↓<br>
[曲線の補間係数, 最小二乗フィットの係数を求める]<br>
↓<br>
出力(グラフ描画)<br>
</center>
<br>
ロググラフを作成する場合, 曲線の補間はデータを対数変換した後に行われるので通常の線形グラフとロググラフでは結果が異なります。
最小二乗法に関してはロググラフでも通常の線形グラフと同じ係数を求めます。<br>
</div>

<br>
<hr>
<br>

<h2><a name="FORMULA_COMMENT" href="#TOP">数式変換で使用できるコメント</a></h2>
#から行末までをコメントと見なします。

<h2><a name="FORMULA_LITERAL" href="#TOP">数式変換で使用できる数値リテラル</a></h2>
<br>
<div>
<dl>
 <dt>1</dt>
 <dt>1.0</dt>
 <dt>1.0E3</dt>
 <dd>
      <p>浮動小数点</p>
      </dd>
 <dt>0xffff</dt>
 <dd>
      <p>16進整数</p>
      </dd>
 <dt>0b1011</dt>
 <dd>
      <p>2進整数</p>
      </dd>
 <dt>0o377</dt>
 <dd>
      <p>8進整数</p>
      </dd>
</dl>
<p>数字が連続している部分は見やすくするため任意の箇所に空白を入れることが出来ます (例 123 456.789 E8) 。</p>
</div>

<br>
<hr>
<br>

<h2><a name="FORMULA_CONST" href="#TOP">数式変換で使用できる定数</a></h2>
<br>
<div>
<table border="1">
 <tr><td>PI</td><td>円周率</td></tr>
 <tr><td>E</td><td>自然対数の底</td></tr>
 <tr><td>EULER</td><td>オイラーの定数</td></tr>
 <tr><td>NAN</td><td>欠損データ エラー表示</td></tr>
 <tr><td>UNDEF</td><td>欠損データ エラー非表示</td></tr>
 <tr><td>CONT</td><td>欠損データ (データ線は結合)</td></tr>
 <tr><td>BREAK</td><td>欠損データ (データ線は分断)</td></tr>
 <tr><td>NUM</td><td>データの個数</td></tr>
 <tr><td>MINX</td><td>(X) column の生データの最小値</td></tr>
 <tr><td>MAXX</td><td>(X) column の生データの最大値</td></tr>
 <tr><td>MINY</td><td>(Y) column の生データの最小値</td></tr>
 <tr><td>MAXY</td><td>(Y) column の生データの最大値</td></tr>
 <tr><td>SUMX</td><td>(X) column の生データの和</td></tr>
 <tr><td>SUMY</td><td>(Y) column の生データの和</td></tr>
 <tr><td>SUMXX</td><td>(X) column の生データの二乗和</td></tr>
 <tr><td>SUMYY</td><td>(Y) column の生データの二乗和</td></tr>
 <tr><td>SUMXY</td><td>(X) column, (Y) column の生データの積和</td></tr>
 <tr><td>AVX</td><td>(X) column の生データの平均</td></tr>
 <tr><td>AVY</td><td>(Y) column の生データの平均</td></tr>
 <tr><td>STDEVPX</td><td>(X) column の生データの標準偏差 (SGX も利用可)</td></tr>
 <tr><td>STDEVPY</td><td>(Y) column の生データの標準偏差 (SGY も利用可)</td></tr>
 <tr><td>STDEVX</td><td>(X) column の生データの不偏標準偏差</td></tr>
 <tr><td>STDEVY</td><td>(Y) column の生データの不偏標準偏差</td></tr>
 <tr><td>FIRST</td><td>diagonal, errorbar など一行のデータで2回の変換が行われる場合、1回目の呼出しで真(=1)、2回目の呼出しで偽(=0)</td></tr>
 <tr><td>MASK</td><td>マスクに設定された行数</td></tr>
 <tr><td>MOVE</td><td>移動に設定された行数</td></tr>
 <tr><td>COLX</td><td>「X カラム」に指定された数</td></tr>
 <tr><td>COLY</td><td>「Y カラム」に指定された数</td></tr>
 <tr><td>AXISX</td><td>「X 軸」に指定された axis オブジェクトの ID</td></tr>
 <tr><td>AXISX_MIN</td><td>「X 軸」の最小値</td></tr>
 <tr><td>AXISX_MAX</td><td>「X 軸」の最大値</td></tr>
 <tr><td>AXISX_LEN</td><td>「X 軸」の長さ</td></tr>
 <tr><td>AXISY</td><td>「Y 軸」に指定された axis オブジェクトの ID</td></tr>
 <tr><td>AXISY_MIN</td><td>「Y 軸」の最小値</td></tr>
 <tr><td>AXISY_MAX</td><td>「X 軸」の最大値</td></tr>
 <tr><td>AXISY_LEN</td><td>「Y 軸」の長さ</td></tr>
 <tr><td>HSKIP</td><td>「先頭スキップ行」に指定された行数</td></tr>
 <tr><td>RSTEP</td><td>「読込ステップ行」に指定された行数</td></tr>
 <tr><td>FLINE</td><td>「最終行」に指定された行数</td></tr>
 <tr><td>DATA_OBJ</td><td>data オブジェクトのオブジェクト識別番号</td></tr>
 <tr><td>PATH_OBJ</td><td>path オブジェクトのオブジェクト識別番号</td></tr>
 <tr><td>RECT_OBJ</td><td>rectangle オブジェクトのオブジェクト識別番号</td></tr>
 <tr><td>ARC_OBJ</td><td>arc オブジェクトのオブジェクト識別番号</td></tr>
 <tr><td>MARK_OBJ</td><td>mark オブジェクトのオブジェクト識別番号</td></tr>
 <tr><td>TEXT_OBJ</td><td>text オブジェクトのオブジェクト識別番号</td></tr>
 <tr><td>%D</td><td>データの番号</td></tr>
 <tr><td>%N</td><td>データオブジェクトのインスタンス数</td></tr>
 <tr><td>TRUE</td><td>代表的な真の値</td></tr>
 <tr><td>FALSE</td><td>偽の値</td></tr>
 <tr><td>FILL_RULE_NONE</td><td>ポリゴンを塗りつぶさない。draw_polygon() 関数で利用する。</td></tr>
 <tr><td>FILL_RULE_EVEN_ODD</td><td>ポリゴンを偶奇則で塗りつぶす。draw_polygon() 関数で利用する。</td></tr>
 <tr><td>FILL_RULE_WINDING</td><td>ポリゴンをワインディング則で塗りつぶす。draw_polygon() 関数で利用する。</td></tr>
</table>
</div>

<br>
<hr>
<br>

<h2><a name="CONST_DEF" href="#TOP">定数定義</a></h2>
<br>
<div>
<table border="1">
 <tr>
  <td>const x:=exp</td>
  <td>
   x は英字または _ で始まり英数字または _ から構成される文字列、exp は任意の数式。<br>
   <ul>
    <li> 既存の定数は上書きできません。
    <li> 数式 exp は数式変換実行時ではなく構文解析時に評価されます。
    <li> 数式 exp 中ではパラメータ、関数 sum(), dif() は使用できません。
   </ul>
  </td>
 </tr>
</table>
</div>

<br>
<hr>
<br>

<h2><a name="FORMULA_PAR" href="#TOP">数式変換で使用できるパラメータ</a></h2>
<br>
<div>
<table border="1">
 <tr><td>%0</td><td>データを読み込んだ順番に1から番号をつけたときの値</td></tr>
 <tr><td>%1〜%999</td><td>同一行中 1〜999 カラムの生データ</td></tr>
 <tr><td>%Fxx1〜%Fxx999</td><td>データ xx の同じ行の 1〜999 カラムの生データ</td></tr>
</table>
</div>

<br>
<hr>
<br>


<h2><a name="FORMULA_VAR" href="#TOP">数式変換で使用できる変数</a></h2>
<p>変数は X, Y の変換式で独立です。</p>
<br>
<div>
<table border="1">
 <tr><td>PI, E, X, Y 以外の、英字または _ で始まり英数字または _ から構成される文字列。</td>
  <td>ユーザが自由に使用できます (代入されていない変数は 0 に初期化されています) 。</td></tr>
 <tr><td>X</td><td>(X)column の生のデータ (変数への代入は可能ですが、データ読込時に生データで上書きされます) </td></tr>
 <tr><td>Y</td><td>(Y)column の生のデータ (変数への代入は可能ですが、データ読込時に生データで上書きされます) </td></tr>
</table>
</div>

<br>
<hr>
<br>

<h2><a name="ARRAY" href="#TOP">配列</a></h2>
<br>
<div>
<table border="1">
 <tr>
  <td>COL[n]</td>
  <td>
    COL[0] はパラメータ %0 とおなじ、それ以外は同一行中 n カラムの生
    データ (999 カラム以降も参照可能)。
  </td>
 </tr>
 <tr>
  <td>X[n]</td>
  <td>
    X は英字または _ で始まり英数字または _ から構成される文字列、n は任意の数式。<br>
   未代入の配列要素は 0 に初期化されています。<br>
   配列の添字は整数に丸められます。<br>
   配列の添字の上限は 65535 です。<br>
   配列の添字に負の数値を使用した場合、配列の末尾からのインデックスとみなします。<br>
  </td>
 </tr>
</table>
</div>

<br>
<hr>
<br>

<h2><a name="STRINGS" href="#TOP">数式変換で使用できる文字列と文字列変数</a></h2>
<h3>注意</h3>
<p>文字列の扱いについては今の所試験的な実装です。今後、仕様変更などの可能性があります。</p>

<h3>文字列リテラル</h3>
<p>文字列はダブルクォートで囲まれています。文字列ではバックスラッシュ記法が有効です。</p>

<h3>文字列変数</h3>
<p>$ に続き英字または _ で始まり英数字または _ から構成される文字列。</p>

<h3>文字列の値</h3>
<p>数値の計算が行われる箇所で、文字列は 0 として扱われます。</p>

<h3>演算子</h3>
<p>文字列に対しては、代入演算子 := のみが使用できます。</p>

<h3>文字列操作関数</h3>
<p><a href="#STRING_FUNC">文字列操作関数</a></p>

<h2><a name="USR_FUNC" href="#TOP">ユーザ定義関数</a></h2>
<br>
<div>
<table border="1">
 <tr>
  <td>def func(a,b,...) {exp} </td>
  <td>
   仮引数 a, b, ... の関数 func を定義します。 <br>
   配列を渡すときは仮引数を @a の様に指定してください。配列は参照渡しとなります。<br>
   exp には任意の数式を指定できますが、以下の制限があります。<br>
   <ul>
    <li> パラメータ (%0, %F0001 など) は使用できません。
    <li> 関数 dif(), sum() は使用できません。
    <li> 関数定義はネストできません。
   </ul>
  </td>
 </tr>
</table>
</div>

<br>
<hr>
<br>

<h2><a name="FORMULA_OP" href="#TOP">数式変換で使用できる演算子</a></h2>
<br>
<div>
<table border="1">
 <tr><td>-+</td><td>符号</td></tr>
 <tr><td>+ - * /</td><td>四則演算</td></tr>
 <tr><td>\</td><td>浮動小数点剰余</td></tr>
 <tr><td>^</td><td>ベキ乗</td></tr>
 <tr><td>!</td><td>階乗(引数は 169 以下の正の整数)</td></tr>
 <tr><td>:=</td><td>代入</td></tr>
 <tr><td>-=</td><td>自己代入</td></tr>
 <tr><td>+=</td><td>自己代入</td></tr>
 <tr><td>*=</td><td>自己代入</td></tr>
 <tr><td>/=</td><td>自己代入</td></tr>
 <tr><td>\=</td><td>自己代入</td></tr>
 <tr><td>^=</td><td>自己代入</td></tr>
 <tr><td>==</td><td>比較</td></tr>
 <tr><td>!=</td><td>比較</td></tr>
 <tr><td>&lt;=</td><td>比較</td></tr>
 <tr><td>&gt;=</td><td>比較</td></tr>
 <tr><td>&lt;</td><td>比較</td></tr>
 <tr><td>&gt;</td><td>比較</td></tr>
 <tr><td>&amp;&amp;</td><td>論理積</td></tr>
 <tr><td>||</td><td>論理和</td></tr>
</table>

<dl>
 <dt> exp1 &amp;&amp; exp2 と AND(exp1, exp2) の違い。</dt>
 <dd> <p>exp1 &amp;&amp; exp2 は exp1 が偽の時 exp2 を評価しません。また exp1 が真の場合、exp2 を評価した値を返します。</p></dd>
 <dt> exp1 || exp2 と OR(exp1, exp2) の違い。</dt>
 <dd> <p>exp1 || exp2 は exp1 が真の時 exp2 を評価しません。また exp1 が真の場合は exp1、exp1 が偽の場合は exp2 を評価した値を返します。</p></dd>
 <dt> ;
 <dd> <p>; は式の終端を表します(省略可能)。; の後に別の式を後に続けることができます。</p>
 <dt> 括弧 ()
 <dd> <p>括弧 () の数に制限はありません。</p>


</dl>

</div>

<br>
<hr>
<br>



<h2><a name="FORMULA_FUNC" href="#TOP">数式変換で使用できる関数</a></h2>
<p>
<ul>
 <li> 引数は省略することが出来ます。引数が省略された場合 0 が渡されます。
 <li> IF() 関数のネスト数、DIF(), SUM() 関数の数の制限はなくなりました。
 <li> 引数は左から評価されます。
</ul>
</p>
<div>
<h3><a name="TRANSFORM_FUNC" href="#TOP">変換関数</a></h3>
<table border="1">
 <tr><td>ABS(x)</td><td>絶対値</td></tr>
 <tr><td>SIGN(x)</td><td>正負の符号 (x < 0 で -1、x >= 0 で 1) </td></tr>
 <tr><td>INT(x)</td><td>0に向かって切捨てた整数部</td></tr>
 <tr><td>GAUSS(x)</td><td>ガウスの記号[ ] ([n]はnを越えない最大の整数)</td></tr>
 <tr><td>FRAC(x)</td><td>小数部</td></tr>
 <tr><td>ROUND(x)</td><td>四捨五入した整数部</td></tr>
 <tr><td>MIN(a,b,c,...)</td><td>引数のうちもっとも小さな値</td></tr>
 <tr><td>MAX(a,b,c,...)</td><td>引数のうちもっとも大きな値</td></tr>
 <tr><td>SUMSQ(a,b,c,...)</td><td>引数の自乗和</td></tr>
</table>
<br>
<h3><a name="ELEMENTARY_FUNC" href="#TOP">初等関数</a></h3>
<table border="1">
 <tr><td>SQR(x)</td><td>二乗</td></tr>
 <tr><td>SQRT(x)</td><td>平方根</td></tr>
 <tr><td>EXP(x)</td><td>指数(x≦690)</td></tr>
 <tr><td>LN(x)</td><td>自然対数</td></tr>
 <tr><td>LOG(x)</td><td>常用対数</td></tr>
 <tr><td>SIN(x)</td><td>サイン</td></tr>
 <tr><td>COS(x)</td><td>コサイン</td></tr>
 <tr><td>TAN(x)</td><td>タンジェント</td></tr>
 <tr><td>ASIN(x)</td><td>逆サイン</td></tr>
 <tr><td>ACOS(x)</td><td>逆コサイン</td></tr>
 <tr><td>ATAN(x)</td><td>逆タンジェント</td></tr>
 <tr><td>SINH(x)</td><td>ハイパボリックサイン</td></tr>
 <tr><td>COSH(x)</td><td>ハイパボリックコサイン</td></tr>
 <tr><td>TANH(x)</td><td>ハイパボリックタンジェント</td></tr>
 <tr><td>ASINH(x)</td><td>逆ハイパボリックサイン</td></tr>
 <tr><td>ACOSH(x)</td><td>逆ハイパボリックコサイン</td></tr>
 <tr><td>ATANH(x)</td><td>逆ハイパボリックタンジェント</td></tr>
 <tr><td>FMOD(x, y)</td><td>x を y で割った浮動小数点剰余</td></tr>
 <tr><td>CHOOSE(n,m)</td><td>the combinatorial factor n choose m: n!/(m!(n-m)!)</td></tr>
</table>
<br>
<h3><a name="SPECIAL_FUMC" href="#TOP">特殊関数</a></h3>
<table border="1">
 <tr><td>RAND(x)</td><td>0≦RAND(x)＜x (x＞0のとき)の乱数</td></tr>
 <tr><td>SRAND(x)</td><td>RAND()  関数で作られる疑似乱数系列の新しい種を設定する。</td></tr>
 <tr><td>THETA(x)</td><td>階段関数(x≧0 のとき 1,  それ以外は 0 )</td></tr>
 <tr><td>DELTA(x)</td><td>クロネッカーのδ(x=0 のとき 1, それ以外は 0)</td></tr>
 <tr><td>GAMMA(x)</td><td>ガンマ関数 Γ(x)</td></tr>
 <tr><td>ICGAM(m,x)</td><td>不完全ガンマ関数 Γ(μ,x)</td></tr>
 <tr><td>ERF(x)</td><td>誤差関数 Erf(x)</td></tr>
 <tr><td>ERFC(x)</td><td>相補誤差関数 Erfc(x)</td></tr>
 <tr><td>QINV(x)</td><td>誤差関数 Erfc(x) の逆関数</td></tr>
 <tr><td>EI(x)</td><td>積分指数関数 Ei(x)</td></tr>
 <tr><td>BETA(p,q)</td><td>ベータ関数 B(p,q)</td></tr>
 <tr><td>ICBETA(a,b,x)</td><td>不完全ベータ関数 I(a,b,x) (0 &lt;= x &lt;= 1) </td></tr>
 <tr><td>JN(n,x)</td><td>第1種n次ベッセル関数</td></tr>
 <tr><td>YN(n,x)</td><td>第2種n次ベッセル関数</td></tr>
 <tr><td>IN(n,x)</td><td>第1種n次変形ベッセル関数</td></tr>
 <tr><td>KN(n,x)</td><td>第2種n次変形ベッセル関数</td></tr>
 <tr><td>JL(l,x)</td><td>第1種l次球ベッセル関数</td></tr>
 <tr><td>YL(l,x)</td><td>第2種l次球ベッセル関数</td></tr>
 <tr><td>JNU(nu,x)</td><td>第1種nu次ベッセル関数 (nu は正の実数) </td></tr>
 <tr><td>YNU(nu,x)</td><td>第2種nu次ベッセル関数 (nu は正の実数) </td></tr>
 <tr><td>INU(nu,x)</td><td>第1種nu次変形ベッセル関数 (nu は正の実数) </td></tr>
 <tr><td>KNU(nu,x)</td><td>第2種nu次変形ベッセル関数 (nu は正の実数) </td></tr>
 <tr><td>PN(n,x)</td><td>ルジャンドル多項式</td></tr>
 <tr><td>LGN(n,a,x)</td><td>ラゲール倍多項式</td></tr>
 <tr><td>HN(n,x)</td><td>エルミート多項式</td></tr>
 <tr><td>TN(n,x)</td><td>チェビシフ多項式</td></tr>
 <tr><td>ZETA(x)</td><td>リーマンゼータ関数 ζ(x)</td></tr>
 <tr><td>ZETA_INT(x)</td><td>リーマンゼータ関数 ζ(x) (x は整数) </td></tr>
 <tr><td>ZETAM1(x)</td><td>リーマンゼータ関数 ζ(x) - 1</td></tr>
 <tr><td>ZETAM1_INT(x)</td><td>リーマンゼータ関数 ζ(x) - 1 (x は整数) </td></tr>
</table>
<br>
<h3><a name="DATETIME_FUMC" href="#TOP">日付時刻関数</a></h3>
<br>
<table border="1">
 <tr><td>MJD(year,month,day,hour,min,sec)</td><td>修正ユリウス日(year, month, day はグレゴリオ暦、hour,min,sec は UTC 時刻、うるう秒は考慮されない)</td></tr>
 <tr><td>UNIX2MJD(time)</td><td>修正ユリウス日(time は 1970年1月1日00:00:00 UTC からの経過秒数、うるう秒は考慮されない)</td></tr>
 <tr><td>MJD2UNIX(mjd)</td><td>修正ユリウス日 mjd の1970年1月1日00:00:00 UTC からの経過秒数(うるう秒は考慮されない)</td></tr>
 <tr><td>MJD2YEAR(mjd)</td><td>修正ユリウス日に対応するグレゴリオ暦の年</td></tr>
 <tr><td>MJD2MONTH(mjd)</td><td>修正ユリウス日に対応するグレゴリオ暦の月</td></tr>
 <tr><td>MJD2DAY(mjd)</td><td>修正ユリウス日に対応するグレゴリオ暦の日</td></tr>
 <tr><td>MJD2WDAY(mjd)</td><td>修正ユリウス日に対応するグレゴリオ暦の曜日 (1:月曜日 から 7:日曜日) </td></tr>
 <tr><td>MJD2YDAY(mjd)</td><td>修正ユリウス日に対応するグレゴリオ暦の 1 月 1 日からの通算日数 (1 から 366) </td></tr>
 <tr><td>TIME()</td><td>紀元 (1970年1月1日00:00:00 UTC) からの経過時間を秒単位で返す。</td></tr>
</table>
<br>
<h3><a name="LOGIC_FUNC" href="#TOP">論理関数</a></h3>
<p>
<ul>
 <li> 0 を偽, それ以外を真とする。
</ul>
</p>
<table border="1">
 <tr><td>EQ(x,y,prec)</td><td>x＝y のとき真(=1)。prec で比較の桁数を指定できる (prec == 0 は完全一致) 。</td></tr>
 <tr><td>NEQ(x,y,prec)</td><td>x≠y のとき真(=1)。prec で比較の桁数を指定できる (prec == 0 は完全一致) 。</td></tr>
 <tr><td>GE(x,y,prec)</td><td>x≧y のとき真(=1)。prec で比較の桁数を指定できる (prec == 0 は桁数指定なし) 。</td></tr>
 <tr><td>GT(x,y,prec)</td><td>x＞y のとき真(=1)。prec で比較の桁数を指定できる (prec == 0 は桁数指定なし) 。</td></tr>
 <tr><td>LE(x,y,prec)</td><td>x≦y のとき真(=1)。prec で比較の桁数を指定できる (prec == 0 は桁数指定なし) 。</td></tr>
 <tr><td>LT(x,y,prec)</td><td>x＜y のとき真(=1)。prec で比較の桁数を指定できる (prec == 0 は桁数指定なし) 。</td></tr>
 <tr><td>NOT(x)</td><td>x＝0 のとき真(=1)</td></tr>
 <tr><td>OR(x,y)</td><td>(x≠0) or (y≠0) のとき真(=1)</td></tr>
 <tr><td>AND(x,y)</td><td>(x≠0) and (y≠0) のとき真(=1)</td></tr>
 <tr><td>XOR(x,y)</td><td>(x≠0) xor (y≠0) のとき真(=1)</td></tr>
</table>
<br>
<h3><a name="ARRAY_FUNC" href="#TOP">配列操作関数</a></h3>
<table border="1">
 <tr><td>ARRAY(a, v1, v2, ...)</td><td>配列 a を残りの引数で初期化する。配列の要素数を返す。</td></tr>
 <tr><td>SIZE(a)</td><td>配列 a の要素数</td></tr>
 <tr><td>SORT(a)</td><td>配列 a を整列する</td></tr>
 <tr><td>RSORT(a)</td><td>配列 a を逆順に整列する</td></tr>
 <tr><td>POP(a)</td><td>配列 a から末尾の要素を取り除いてそれを返す</td></tr>
 <tr><td>PUSH(a,x)</td><td>配列 a の末尾に x を追加する (戻り値は x) </td></tr>
 <tr><td>SHIFT(a)</td><td>配列 a の先頭の要素を取り除いてそれを返す。残りの要素はひとつずつ前に詰められる</td></tr>
 <tr><td>UNSHIFT(a,x)</td><td>配列 a の先頭に x を挿入する (戻り値は x) </td></tr>
 <tr><td>ARRAY_SUM(a)</td><td>配列 a の要素の和を返す </td></tr>
 <tr><td>ARRAY_SUMSQ(a)</td><td>配列 a の要素の自乗和を返す </td></tr>
 <tr><td>ARRAY_AVERAGE(a)</td><td>配列 a の要素の平均を返す </td></tr>
 <tr><td>ARRAY_STDEVP(a)</td><td>配列 a の要素の標準偏差を返す </td></tr>
 <tr><td>ARRAY_STDEV(a)</td><td>配列 a の要素の不偏標準偏差を返す </td></tr>
 <tr><td>ARRAY_MAX(a)</td><td>配列 a に含まれる最大の値を返す </td></tr>
 <tr><td>ARRAY_MIN(a)</td><td>配列 a に含まれる最小の値を返す </td></tr>
 <tr><td>ARRAY_CLEAR(a)</td><td>配列 a の配列の要素数を 0 にする </td></tr>
 <tr><td>ARRAY_COMPACT(a)</td><td>配列 a の配列の要素から通常の数値以外を取り除き、取り除いた後の要素数を返す</td></tr>
</table>
<br>
<h3><a name="MEMORY_FUNC" href="#TOP">メモリー操作関数</a></h3>
<p>メモリーは全ての数式変換で共有されます。</p>
<table border="1">
 <tr><td>M(i,x)</td><td>引数を第iメモリーに代入する(i=0〜65535)、i が負のときは末尾からのインデックス (戻り値は x) </td></tr>
 <tr><td>RM(i)</td><td>現在の第iメモリーの値(i=0〜65535)、i が負のときは末尾からのインデックス</td></tr>
 <tr><td>CM(x,n)</td><td>先頭からn個のメモリーを x で初期化する、n が 0 のときはメモリー全体、n が負のときは末尾から n 個のメモリーを x で初期化する (戻り値は x) </td></tr>
 <tr><td>AM(a)</td><td>配列 a の内容をメモリーにコピーする (戻り値はコピーした要素数) </td></tr>
</table>
<br>
<h3><a name="DRAWING_FUNC" href="#TOP">図形描画関数</a></h3>
<p>図形を描画します。</p>
<ul>
  <li> 本来のプロットも描画されるので、不要な場合はプロットタイプを
    mark に、サイズを 0 にすることで、図形のみ描画させることができます。
  <li> 描画される図形は軸のオートスケールには考慮されません。
  <li> 図形の色や線幅・線種はそのファイルオブジェクトの設定が使われま
    す。変えたい場合は COLOR() 関数などを利用します。
</ul>
<table border="1">
  <tr>
    <td>
      DRAW_RECT(x, y, w, h, stroke, fill)
    </td>
    <td>
      (x, y) と (x + w, y + h) を対角の頂点とする矩形を描画します。stroke,
      fill が 0 の場合はそれぞれ輪郭、塗りつぶしを描画しません。
    </td>
  </tr>
  <tr>
    <td>
      DRAW_ARC(x, y, rx, ry, start, stop, pieslice, stroke, fill, close)
    </td>
    <td>
      (x, y) を中心とし X 方向半径 rx, Y 方向半径 ry の円弧を描画しま
      す。start, stop で開始角、円弧角を指定します。stroke, fill が 0
      の場合はそれぞれ輪郭、塗りつぶしを描画しません。pieslice が 0 以
      外の場合は扇形を描画します。close が 0 以外の場合は輪郭を閉じま
      す。
    </td>
  </tr>
  <tr>
    <td>
      DRAW_MARK(x, y, size)
    </td>
    <td>
      (x, y) にマークを描画します。size でマークのサイズを指定できます。
      size が 0 のときはファイルオブジェクトのサイズ指定が使われます。
    </td>
  </tr>
  <tr>
    <td>
      DRAW_LINE(x1, y1, x2, y2)
    </td>
    <td>
      (x1, y1) から (x2, y2) に直線を描画します。
    </td>
  </tr>
  <tr>
    <td>
      DRAW_POLYLINE(ax, ay)
    </td>
    <td>
      座標 (ax[0], ay[0]), (ax[1], ay[1]), ... を直線で結びます。
    </td>
  </tr>
  <tr>
    <td>
      DRAW_POLYGON(ax, ay, stroke, fill)
    </td>
    <td>
      座標 (ax[0], ay[0]), (ax[1], ay[1]), ... で囲まれた領域を描画します。
      stroke, fill が 0 の場合はそれぞれ輪郭、塗りつぶしを描画しません。
    </td>
  </tr>
  <tr>
    <td>
      DRAW_ERRORBAR(x, y, erx, ery, size)
    </td>
    <td>
      (x - erx, y) から (x + erx, y) および (x, y - ery) から (x, y +
      ery) に誤差棒を描画する。size で tick の長さを指定できる。size が
      0 のときはファイルオブジェクトのサイズ指定が使われる。
    </td>
  </tr>
  <tr>
    <td>
      DRAW_ERRORBAR2(x1, y1, x2, y2, size)
    </td>
    <td>
      (x1, y1) から (x2, y2) に誤差棒を描画する。size で tick の長さを
      指定できる。size が 0 のときはファイルオブジェクトのサイズ指定が
      使われる。
    </td>
  </tr>
</table>
<br>
<h3><a name="STRING_FUNC" href="#TOP">文字列操作関数</a></h3>
<table border="1">
  <tr>
    <td>
     string_float($str)
    </td>
    <td>
      $str を浮動小数点に変換し、その値を返します
    </td>
  </tr>
  <tr>
    <td>
     string_length($str)
    </td>
    <td>
      $str に含まれる文字数を返します。UTF-8 以外の文字列では使えません。
    </td>
  </tr>
  <tr>
    <td>
     string_format($str, value)
    </td>
    <td>
      数値 value を文字列に変換して $str に代入します。
    </td>
  </tr>
  <tr>
    <td>
     string_up($dest, $src)
    </td>
    <td>
     文字列 $src に含まれる ascii 文字を大文字にした文字列を $dest に代入します。
    </td>
  </tr>
  <tr>
    <td>
     string_down($dest, $src)
    </td>
    <td>
     文字列 $src に含まれる ascii 文字を小文字にした文字列を $dest に代入します。
    </td>
  </tr>
  <tr>
    <td>
     string_strip($str)
    </td>
    <td>
     文字列 $str の先頭、最後にある空白文字を削除します。
    </td>
  </tr>
  <tr>
    <td>
     string_append($dest, $src)
    </td>
    <td>
     文字列 $dest の最後に文字列 $src を連結します。
    </td>
  </tr>
  <tr>
    <td>
     string_prepend($dest, $src)
    </td>
    <td>
     文字列 $dest の最初に文字列 $src を連結します。
    </td>
  </tr>
  <tr>
    <td>
     string_insert($dest, $src, pos)
    </td>
    <td>
     文字列 $dest の pos 番目の文字の前に文字列 $src を挿入します。
    </td>
  </tr>
  <tr>
    <td>
     string_reverse($dest, $src)
    </td>
    <td>
     文字列 $src の並びを逆にした文字列を $dest に代入します。UTF-8 以外の文字列では使えません。
    </td>
  </tr>
  <tr>
    <td>
     string_compare($str1, $str2, ignore_case)
    </td>
    <td>
      2つの文字列 $str1 と $str2 を比較して $str1 が $str2 に較べて 1)小
     さい、2)等しい、3)大きい場合に、ゼロよりも 1)小さい、2)等しい、3)大
     きい整数を返します。ignore_case が 0 以外の場合は文字列に含まれる
     ascii 文字の大文字小文字を区別せずに比較します。
    </td>
  </tr>
  <tr>
    <td>
     string_match($str, $regexp, ignore_case)
    </td>
    <td>
     文字列 $str に対して、文字列 $regexp が表す正規表現によるマッチング
     を行います。マッチした場合は 0 以外の数値、マッチしなかった場合は 0
     を返します。ignore_case が 0 以外の場合は文字列に含まれる ascii 文
     字の大文字小文字を区別せずに比較します。
    </td>
  </tr>
  <tr>
    <td>
     string_truncate($str, len)
    </td>
    <td>
     文字列 $str の先頭 len 文字以降を削除します。UTF-8 以外の文字列では使えません。
    </td>
  </tr>
  <tr>
    <td>
     string_erase($str, pos, len)
    </td>
    <td>
     文字列 $str から、pos 文字目から始まる len 文字を削除します。UTF-8 以外の文字列では使えません。
    </td>
  </tr>
  <tr>
    <td>
     string_substring($dest, $src, start, end)
    </td>
    <td>
     文字列 $src の pos 文字目から始まり end 文字までからなる文字列を $dest に代入します。UTF-8 以外の文字列では使えません。
    </td>
  </tr>
  <tr>
    <td>
     string_split($dest, $src, $separator, index)
    </td>
    <td>
     文字列 $src を文字列 $separator で分割し、分割された index 番目の文字列を $dest に代入します。
    </td>
  </tr>
  <tr>
    <td>
     string_replace($dest, $src, $regexp, $replacement, ignore_case)
    </td>
    <td>
     文字列 $src 中の、文字列 $regexp が表す正規表現にマッチする文字列を
     $replacement で置換します。ignore_case が 0 以外の場合は文字列に含
     まれる ascii 文字の大文字小文字を区別せずに比較します。
    </td>
  </tr>
  <tr>
    <td>
     string_column($dest, index)
    </td>
    <td>
     データファイルを読み込んだ時に index カラムの文字列を $dest に代入
     します。index が 0 のときは行全体の文字列が代入されます。
    </td>
  </tr>
  <tr>
    <td>
     draw_text($str, x, y, font, pt, dir, space, script)
    </td>
    <td>
     (x, y) に文字列 $str を描画します。font は 0, 1, 2 がそれぞれ
     Sans-serif, Serif, Monospace に対応します。続く引数で方向、文字間隔、
     スクリプトサイズを指定できます。
    </td>
  </tr>
</table>
<br>
<h3><a name="OTHER_FUNC" href="#TOP">その他の関数</a></h3>
<table border="1">
 <tr>
  <td>FIT_PRM(id,x)</td>
  <td>
   ID が id の data オブジェクトのプロットタイプが fit のとき、対応す
   る fit object のフィールド "%0x" の値。
  </td>
 </tr>
 <tr>
  <td>FIT_CALC(id,x)</td>
  <td>
   ID が id の data オブジェクトのプロットタイプが fit のとき、対応する
   fit 結果 f(x) を計算する。
  </td>
 </tr>
 <tr><td>LINE_NUMBER()</td><td>処理中のファイル行番号 (1行目が1) </td></tr>
 <tr><td>ISNORMAL(x)</td><td>x が通常の数値の場合真</td></tr>
 <tr><td>ISBREAK(x)</td><td>x が BREAK の場合真</td></tr>
 <tr><td>ISCONT(x)</td><td>x が CONT の場合真</td></tr>
 <tr><td>ISNAN(x)</td><td>x が NAN の場合真</td></tr>
 <tr><td>ISUNDEF(x)</td><td>x が UNDEF の場合真</td></tr>
 <tr><td>SUM(x)</td><td>積算</td></tr>
 <tr><td>DIF(x)</td><td>差分</td></tr>
 <tr><td>F(x,y,z)</td><td>ユーザ定義関数</td></tr>
 <tr><td>G(x,y,z)</td><td>ユーザ定義関数</td></tr>
 <tr><td>H(x,y,z)</td><td>ユーザ定義関数</td></tr>
 <tr><td>COLOR(0,x)</td><td>R値を x (0≦x＜256)に設定</td></tr>
 <tr><td>COLOR(1,x)</td><td>G値を x (0≦x＜256)に設定</td></tr>
 <tr><td>COLOR(2,x)</td><td>B値を x (0≦x＜256)に設定</td></tr>
 <tr><td>COLOR(3,x)</td><td>RGB値を x (0≦x＜256)に設定</td></tr>
 <tr><td>COLOR(4,x)</td><td>R2値を x (0≦x＜256)に設定</td></tr>
 <tr><td>COLOR(5,x)</td><td>G2値を x (0≦x＜256)に設定</td></tr>
 <tr><td>COLOR(6,x)</td><td>B2値を x (0≦x＜256)に設定</td></tr>
 <tr><td>COLOR(7,x)</td><td>R2, G2, B2 値を x (0≦x＜256)に設定</td></tr>
 <tr><td>COLOR(8,x)</td><td>x を 6 桁の 16 進数として、 2 桁ずつ R, G, B 値に設定</td></tr>
 <tr><td>COLOR(9,x)</td><td>x を 6 桁の 16 進数として、 2 桁ずつ R2, G2, B2 値に設定</td></tr>
 <tr><td>OBJ_COLOR(id, DATA_OBJ), OBJ_COLOR(id)</td><td>R, G, B, R2, G2, B2 値を ID が id の data オブジェクトと同じ値にする。</td></tr>
 <tr><td>OBJ_COLOR(id, PATH_OBJ)</td><td>R, G, B, R2, G2, B2 値を ID が id の path オブジェクトの stroke_R, stroke_G, stroke_B, fill_R, fill_G, fill_B と同じ値にする。</td></tr>
 <tr><td>OBJ_COLOR(id, RECT_OBJ)</td><td>R, G, B, R2, G2, B2 値を ID が id の rectangle オブジェクトの stroke_R, stroke_G, stroke_B, fill_R, fill_G, fill_B と同じ値にする。</td></tr>
 <tr><td>OBJ_COLOR(id, ARC_OBJ)</td><td>R, G, B, R2, G2, B2 値を ID が id の arc オブジェクトの stroke_R, stroke_G, stroke_B, fill_R, fill_G, fill_B と同じ値にする。</td></tr>
 <tr><td>OBJ_COLOR(id, MARK_OBJ)</td><td>R, G, B, R2, G2, B2 値を ID が id の mark オブジェクトと同じ値にする。</td></tr>
 <tr><td>OBJ_COLOR(id, TEXT_OBJ)</td><td>R, G, B 値を ID が id の text オブジェクトと同じ値にする。</td></tr>
 <tr><td>ALPHA(x)</td><td>A, A2 値を x (0≦x＜256)に設定</td></tr>
 <tr><td>ALPHA(x,1)</td><td>A 値を x (0≦x＜256)に設定</td></tr>
 <tr><td>ALPHA(x,2)</td><td>A2 値を x (0≦x＜256)に設定</td></tr>
 <tr><td>OBJ_ALPHA(id, DATA_OBJ), OBJ_ALPHA(id)</td><td>A, A2 値を ID が id の data オブジェクトと同じ値にする。</td></tr>
 <tr><td>OBJ_ALPHA(id, PATH_OBJ)</td><td>A, A2 値を ID が id の path オブジェクトの stroke_A, fill_A と同じ値にする。</td></tr>
 <tr><td>OBJ_ALPHA(id, RECT_OBJ)</td><td>A, A2 値を ID が id の rectangle オブジェクトの stroke_A, fill_A と同じ値にする。</td></tr>
 <tr><td>OBJ_ALPHA(id, ARC_OBJ)</td><td>A, A2 値を ID が id の arc オブジェクトの stroke_A, fill_A と同じ値にする。</td></tr>
 <tr><td>OBJ_ALPHA(id, MARK_OBJ)</td><td>A, A2 値を ID が id の mark オブジェクトと同じ値にする。</td></tr>
 <tr><td>OBJ_ALPHA(id, TEXT_OBJ)</td><td>A 値を ID が id の text オブジェクトと同じ値にする。</td></tr>
 <tr><td>RGB(r,g,b)</td><td>色のRGB値をそれぞれ r, g, b (0≦r,g,b≦1)に設定</td></tr>
 <tr><td>RGB2(r,g,b)</td><td>R2, G2, B2, の値を r, g, b (0≦r,g,b≦1)に設定</td></tr>
 <tr><td>HSB(h,s,b)</td><td>色のHSB値をそれぞれ h, s, b (0≦h,s,b≦1)に設定</td></tr>
 <tr><td>HSB2(h,s,b)</td><td>R2, G2, B2, の値を、HSB値からそれぞれ h, s, b (0≦h,s,b≦1)に設定</td></tr>
 <tr><td>MARKSIZE(x)</td><td>マークのサイズをXに設定</td></tr>
 <tr><td>MARKTYPE(x)</td><td>マークの種類をXに設定</td></tr>
 <tr><td>IF(x,ex1,ex2)</td><td>x ≠ 0 のとき ex1, x = 0 のとき ex2</td></tr>
 <tr><td>UNLESS(x,ex1,ex2)</td><td>x ≠ 0 のとき ex2, x = 0 のとき ex1 </td></tr>
 <tr><td>FOR(m,begin,end,step,ex)</td><td>第mメモリーの値に begin から end まで step で 値を設定し、ex を繰り返す。
     m が負の時はメモリーへの設定は行われない。
     最後に評価された ex の値を返す。
 </td></tr>
 <tr><td>PROG1(arg1,arg2,...)</td><td>引数を評価し、最初の引数の値を返す</td></tr>
 <tr><td>PROG2(arg1,arg2,...)</td><td>引数を評価し、2 番目の引数の値を返す</td></tr>
 <tr><td>PROGN(arg1,arg2,...)</td><td>引数を評価し、最後の引数の値を返す</td></tr>
</table>
</div>

<br>
<hr>
<br>


<h2><a name="OP_PRECEDENCE" href="#TOP">演算子の優先順位</a></h2>
<p>演算子 + - (正負の符号) の優先順位が Version 6.03 以前と異なっています。</p>
<br>
<div>
<table border="1">
 <tr><td>高</td><td>!</td></tr>
 <tr><td>↑</td><td>^</td></tr>
 <tr><td>  </td><td>+ - (正負の符号)</td></tr>
 <tr><td>  </td><td>* / \</td></tr>
 <tr><td>  </td><td>+ -</td></tr>
 <tr><td>  </td><td>&lt; &lt;= &gt; &gt;=</td></tr>
 <tr><td>  </td><td>== !=</td></tr>
 <tr><td>  </td><td>&amp;&amp;</td></tr>
 <tr><td>↓</td><td>||</td></tr>
 <tr><td>低</td><td>:=(+=, -= ... )</td></tr>
</table>
</div>

<br>
<hr>
<br>

<h2><a name="OP_EXAMPLE" href="#TOP">数式変換の使用例</a></h2>
<br>
<ul>
 <li><b>; 使用例</b>
      <p>
      ;  は式の終端を示しますが、さらに続けて別の式を書くことができます。
      式の値は一番最後の式の値になります。
      例えば、長い式が何度も現れるとき変数への代入と組み合わせて
      <pre>
      a:=...式...; ... a ....;
      </pre>
      のようにすれば同じ式は１度書くだけですみます。また式最後の ; は省略できます。
      </p>
      <p>
      (従来は式の終端として "=" が使われていましたが version 6.06.10 以降
      は ";" を推奨とします。)
      </p>
      </li>

 <li><b>メモリー関数 M(), RM() 使用例</b>
      <br>
      <p>
      M() はメモリーへの代入、RM() は読みだしです。全ての数式変換でメモリーは
      共有されるため、データ間での値の受け渡しに利用できます。メ
      モリーは 65536 個 (0〜65535) まで利用できます。また、未使用のメモリーは
      0 に初期化されています。
      </p>
      </li>

 <li><b>比較関数 EQ(), NEQ(), LT(), GT(), LE(), GE() 使用例</b><br>

      <p>数値の比較を行う関数ですが、下記の例のように浮動小数点誤差により
      思った通りの結果が得られない場合があります。</p>
      <pre>
      Ngraph$ iexpr 'EQ(0.5 - 0.4, 0.1)'
      0
      </pre>
      <p>
      このような場合に、３番目の引数で比較の桁数を指定すると期待する結果
      が得られることが多くなります。
      </p>
      <pre>
      Ngraph$ iexpr 'EQ(0.5 - 0.4, 0.1, 14)'
      1
      </pre>
      <p>
      計算によっては浮動小数点誤差の影響が大きくなる場合もありますので注
      意が必要です。
      </p>
      </li>

 <li><b>関数 DIF() 使用例</b>
      <br>
      <br>
      関数 DIF() は微分でなく差分を返す関数です。
      現在のデータがデータ中 n 番目としそれを Y(n) で表すとすると
      <p>
      DIF(Y)=Y(n) - Y(n-1)
      </p>
      です。これを用い簡単に微分近似値を求めるには
      <pre>
      DIF(Y)/DIF(X)
      </pre>
      とします。
      <p>
      DIF(Y)/DIF(X)は {Y(n)-Y(n-1)} / {X(n)-X(n-1)} になります。
      </p>
      この時、Xの変換数式を
      <pre>
      X-DIF(X)*0.5
      </pre>
      としてXを"現在のデータと一つ前のデータの中間値"としておいた方がより真に近いグラフが得られると思われます。
      <p>
      X変換式: X-DIF(X)*0.5 (これは { X(n-1)+X(n) }*0.5 になります)<br>
      Y変換式: DIF(Y)/DIF(X) (これは { Y(n)-Y(n-1) } / { X(n)-X(n-1) } になります)
      </p>
      <p>
      DIF()  は現在のデータと一つ前のデータとの差分を返しますから、Y-DIF(Y) とすることで一つ前のデータを取り出すことができます。
      同様に Y-DIF(Y)-DIF(Y-DIF(Y)) で2つ前のデータを取り出すことができます。
      Y-DIF(Y)-DIF(Y-DIF(Y))-DIF(Y-DIF(Y)-DIF(Y-DIF(Y)))は3つ前のデータです．
      </p>
      <p>
      一番初めの DIF() の戻り値は"不定"です．このため，式全体の値も"不定"となり、結果としてデータの個数は1つ減ります(一番初めのデータに差分は存在しない)。
      また DIF() をいくつも含む式では、全ての DIF() が初期化されるまで式全体の値は"不定"です。
      例えば DIF() をネストして DIF(DIF()) のように使った場合、一番初めのデータでは内側の DIF() が初期化されその戻り値は不定の為、外側の DIF() の初期化は行われません。
      外側の DIF() が初期化されるのは 2番目のデータの時です。
      従ってデータの個数は2つ減ることになります。
      </p>
      <br>
      <br>
      </li>

 <li><b>関数 SUM() 使用例</b>
      <br>
      <br>
      関数 SUM() は積算を返す関数です。
      現在のデータが n 番目としそれを Y(n) で表すとすると
      <p>
      SUM(Y)=Σ Y(n) (n=1..n)
      </p>
      これを用い簡単に積分近似値を求めるには
      <pre>
      SUM(Y*DIF(X))
      </pre>
      とします。
      <p>
      SUM(Y * DIF(X)) は Σ Y(n) * {X(n) - X(n-1)} (n = 1..n) になります。
      </p>
      また、台形公式を用いて積分近似値を評価したい場合
      <pre>
      SUM(0.5 * (2 * Y - DIF(Y)) * DIF(X))
      </pre>
      とします。
      <p>
      SUM(0.5 * (2 * Y - DIF(Y)) * DIF(X)) は Σ(Y(n-1) + Y(n)) / 2  *{X(n) - X(n-1)} (n = 1..n) になります。
      </p>
      さらに積分の上限(b)、下限(a)を指定したい場合は階段関数 THETA() を用い
      <pre>
      SUM(0.5 * (2 * Y-DIF(Y)) * DIF(X) * THETA(X-a) * THETA(b-X))
      </pre>
      とします。IF() を使って
      <pre>
      IF(X &gt;= a && X &lt;= b, SUM(0.5 * (2 * Y - DIF(Y)) * DIF(X)), 0)
      </pre>
      としても可能です。
      <br>
      <br>
      </li>

 <li><b>関数 IF() 使用例</b>
      <br>
      <br>
      IF(x,ex1,ex2) は x が真(&lt;&gt;0)のとき ex1 を，偽(=0)のとき ex2 を返す関数です。例えば次の式
      <pre>
      IF( x &lt; 0, 0, SQRT(x) )
      </pre>
      は x&lt;0 のとき 0、x&gt;=0 のとき√x を返す関数になります。また必ず  ex1, ex2 どちらか一方しか評価されません。
      <br>
      <br>

 <li><b>関数 MARKSIZE(), COLOR() 使用例</b>
      <br>
      <br>
      MARKSIZE()、COLOR()関数は数学関数では無く、それぞれプロットされたマークのサイズ、色を指定する関数です。
      例えば、(x,y,z) の 3 カラムから成るデータがあり、マークのサイズを z の値で変更したいような場合には
      <pre>
      MARKSIZE(%03)
      </pre>
      とします。ただこれですと、プロットされるデータも %03 となりますので、前述の ; を使って
      <pre>
      MARKSIZE(%03);Y
      </pre>
      とするのが正しい使い方です。
      COLOR()関数も同様で
      <pre>
      COLOR(3,%03);Y
      </pre>
      のように使います。
      <br>

 <li><b>関数 OBJ_COLOR() 使用例</b>
      <p>
      data, path, rectangle, arc, mark, text の各オブジェクトの設定色を描
      画色にします。例えばいくつかのフィッティング結果をもとにフィッティ
      ングパラメータをグラフにするような場合、
      <pre>
      OBJ_COLOR(X);FIT_PRM(X,1)
      </pre>
      のようにして、フィッティングとプロットの色を揃えることができます。
      この時 X はフィッティングプロットにした data オブジェクトのインスタ
      ンス ID です。
      </p>

 <li><b>関数 FIT_PRM(),  FIT_CALC() 使用例</b>
      <p>
      フィッティングの結果からそのパラメータや、フィッティング式の計算を
      行う関数です。
      </p>
      <p>
      例えば、いくつかの１次フィットからその傾きをプロットしたい場合、
      <pre>
      FIT_PRM(X,1)
      </pre>
      のようにします。この時 X はフィッティングプロットにした data オブジェ
      クトのインスタンス ID です。
      </p>

      <p>
      また、１次ドリフトのあるデータからドリフト成分を引いてプロットし
      たい場合 (id が 0 の data オブジェクトでフィッティングを行ってい
      るとして)、
      <pre>
      Y-FIT_CALC(0,X)
      </pre>
      のようにします。
      </p>

      <p>
      これらの関数はフィッティングの結果が確定していないと計算に失敗しま
      す。データの描画順に注意してください。また、初回のプロットでオー
      トスケールに反映されないことがあります。
      </p>

 <li><b>関数 PROG1(), PROG2(), PROGN() 使用例</b>
      <p>
      関数 PROG1(), PROG1(), PROGN() は複数の引数を評価して、最初、2番
      目または最後の引数の値を返す関数です。IF(), UNLESS(), FOR() 関数
      の引数に使用して複数の式を評価するために利用できます。下記の例で
      は X の値が 1 以上変化する毎に Y の平均値を計算しています (X は
      1 よりも大きいことを仮定) 。
      </p>
      <pre>
      IF(X - A &lt; 1, PROGN(B += Y, N += 1, CONT), PROG1(IF(N, B / N, CONT), B := Y, N := 1, A := X))
      </pre>
      </li>
 <li><b>図形描画関数の使用例</b>
   <p>
     データから円や矩形を描画できます。例えば、以下のようなデータから
     円グラフを作成することができます。
   </p>
   <p>データ</p>
   <pre>
     1
     2
     3
     4
   </pre>
   <p>変換式</p>
   <pre>
     HSB2(%0/NUM,1,1); X*=360/SUMX; DRAW_ARC(0,0,1,1,SUM(X),-X,1,1,1,1)
   </pre>
   <p>
     HSB2() 関数で塗りつぶしの色を変えながら DRAW_ARC() 関数で扇形を描
     画します。
   </p>
</ul>

</body>
</html>
